// Code generated by suricata-gen; DO NOT EDIT.

package hello

import (
	"context"
	"fmt"
	"github.com/ostafen/suricata/runtime"
	"github.com/xeipuuv/gojsonschema"
)

var (
	SayHelloAllRequestSchema  = gojsonschema.NewStringLoader(`{"properties":{"names":{"items":{"type":"string"},"type":"array"}},"required":["names"],"type":"object"}`)
	SayHelloAllReplySchema    = gojsonschema.NewStringLoader(`{"properties":{"ok":{"type":"boolean"}},"required":["ok"],"type":"object"}`)
	SayHelloToolRequestSchema = gojsonschema.NewStringLoader(`{"properties":{"name":{"description":"the name","type":"string"}},"required":["name"],"type":"object"}`)
	SayHelloToolReplySchema   = gojsonschema.NewStringLoader(`{"properties":{"ok":{"type":"boolean"}},"required":["ok"],"type":"object"}`)
)

type (
	SayHelloAllRequest struct {
		Names []string `json:"names,omitempty"`
	}

	SayHelloAllReply struct {
		Ok bool `json:"ok"`
	}

	SayHelloToolRequest struct {
		Name string `json:"name"`
	}

	SayHelloToolReply struct {
		Ok bool `json:"ok"`
	}
)

type HelloAgentTools interface {
	SayHelloTool(ctx context.Context, in *SayHelloToolRequest) (*SayHelloToolReply, error)
}

var HelloAgentToolsSpec = []runtime.ToolSpec{{Name: "SayHelloTool", Description: "say hello to a given name", Schema: SayHelloToolRequestSchema}}

var HelloAgentInstructions = `You are a helpful and precise assistant. Your role is to say hello to people.
`

type HelloAgent struct {
	runtime *runtime.Runtime
	tools   HelloAgentTools
}

func NewHelloAgent(invoker runtime.Invoker, tools HelloAgentTools) *HelloAgent {
	return &HelloAgent{runtime: runtime.NewRuntime(invoker), tools: tools}
}

func (a *HelloAgent) unmarshaller(method string, data []byte) (any, error) {
	switch method {
	case "SayHelloTool":
		var payload SayHelloToolRequest
		err := runtime.UnmarshalValidate(data, &payload, SayHelloToolRequestSchema)
		return &payload, err
	}

	return nil, fmt.Errorf("no such tool: \"%s\"", method)
}

func (a *HelloAgent) toolsInvoker(ctx context.Context, name string, in any) (any, error) {
	switch name {
	case "SayHelloTool":
		return a.tools.SayHelloTool(ctx, in.(*SayHelloToolRequest))
	}

	return nil, fmt.Errorf("no such tool: \"%s\"", name)
}

func (c *HelloAgent) SayHelloAll(ctx context.Context, in *SayHelloAllRequest) (*SayHelloAllReply, error) {
	prompt := `{{- /* Use Go templating for dynamic prompts */ -}}
Please say hello to all the following names:
{{- range .Names }}
- {{ . }}
{{- end }}
`

	// Invoke LLM runtime
	out := SayHelloAllReply{}
	err := c.runtime.Invoke(ctx, runtime.Request{
		SkipInput:        false,
		Instructions:     HelloAgentInstructions,
		PromptTemplate:   prompt,
		Input:            in,
		Output:           &out,
		InputSchema:      SayHelloAllRequestSchema,
		OutputSchema:     SayHelloAllReplySchema,
		ToolUnmarshaller: c.unmarshaller,
		ToolInvoker:      c.toolsInvoker,
		ToolSpecs:        HelloAgentToolsSpec,
	})
	if err != nil {
		return nil, fmt.Errorf("llm call failed: %w", err)
	}

	return &out, nil
}
