// Code generated by suricata-gen; DO NOT EDIT.

package eval

import (
	"context"
	"fmt"
	"github.com/ostafen/suricata/runtime"
	"github.com/xeipuuv/gojsonschema"
)

var (
	MathRequestSchema = gojsonschema.NewStringLoader(`{"properties":{"a":{"type":"number"},"b":{"type":"number"}},"required":["a","b"],"type":"object"}`)
	MathReplySchema   = gojsonschema.NewStringLoader(`{"properties":{"result":{"type":"number"}},"required":["result"],"type":"object"}`)
	EvalRequestSchema = gojsonschema.NewStringLoader(`{"properties":{"expr":{"type":"string"}},"required":["expr"],"type":"object"}`)
	EvalReplySchema   = gojsonschema.NewStringLoader(`{"properties":{"result":{"type":"number"}},"required":["result"],"type":"object"}`)
)

type (
	MathRequest struct {
		A float64 `json:"a"`
		B float64 `json:"b"`
	}

	MathReply struct {
		Result float64 `json:"result"`
	}

	EvalRequest struct {
		Expr string `json:"expr"`
	}

	EvalReply struct {
		Result float64 `json:"result"`
	}
)

type MathAgentTools interface {
	AddTool(ctx context.Context, in *MathRequest) (*MathReply, error)
	SubTool(ctx context.Context, in *MathRequest) (*MathReply, error)
	MulTool(ctx context.Context, in *MathRequest) (*MathReply, error)
	DivTool(ctx context.Context, in *MathRequest) (*MathReply, error)
}

var MathAgentToolsSpec = []runtime.ToolSpec{{Name: "AddTool", Description: "Add two numbers", Schema: MathRequestSchema}, {Name: "SubTool", Description: "Subtract two numbers", Schema: MathRequestSchema}, {Name: "MulTool", Description: "Multiply two numbers", Schema: MathRequestSchema}, {Name: "DivTool", Description: "Divide two numbers", Schema: MathRequestSchema}}

var MathAgentInstructions = `You are a math assistant. You receive a math expression containing +, -, *, /.
Break it down into steps and use the appropriate tool for each operation.
Return the final numeric result.
`

type MathAgent struct {
	runtime *runtime.Runtime
	tools   MathAgentTools
}

func NewMathAgent(invoker runtime.Invoker, tools MathAgentTools) *MathAgent {
	return &MathAgent{runtime: runtime.NewRuntime(invoker), tools: tools}
}

func (a *MathAgent) unmarshaller(method string, data []byte) (any, error) {
	switch method {
	case "AddTool":
		var payload MathRequest
		err := runtime.UnmarshalValidate(data, &payload, MathRequestSchema)
		return &payload, err
	case "SubTool":
		var payload MathRequest
		err := runtime.UnmarshalValidate(data, &payload, MathRequestSchema)
		return &payload, err
	case "MulTool":
		var payload MathRequest
		err := runtime.UnmarshalValidate(data, &payload, MathRequestSchema)
		return &payload, err
	case "DivTool":
		var payload MathRequest
		err := runtime.UnmarshalValidate(data, &payload, MathRequestSchema)
		return &payload, err
	}

	return nil, fmt.Errorf("no such tool: \"%s\"", method)
}

func (a *MathAgent) toolsInvoker(ctx context.Context, name string, in any) (any, error) {
	switch name {
	case "AddTool":
		return a.tools.AddTool(ctx, in.(*MathRequest))
	case "SubTool":
		return a.tools.SubTool(ctx, in.(*MathRequest))
	case "MulTool":
		return a.tools.MulTool(ctx, in.(*MathRequest))
	case "DivTool":
		return a.tools.DivTool(ctx, in.(*MathRequest))
	}

	return nil, fmt.Errorf("no such tool: \"%s\"", name)
}

func (c *MathAgent) Evaluate(ctx context.Context, in *EvalRequest) (*EvalReply, error) {
	prompt := `{{- /* Decide the operation sequence and tool calls */ -}}
Evaluate the expression: {{ .Expr }}
`

	// Invoke LLM runtime
	out := EvalReply{}
	err := c.runtime.Invoke(ctx, runtime.Request{
		SkipInput:        false,
		Instructions:     MathAgentInstructions,
		PromptTemplate:   prompt,
		Input:            in,
		Output:           &out,
		InputSchema:      EvalRequestSchema,
		OutputSchema:     EvalReplySchema,
		ToolUnmarshaller: c.unmarshaller,
		ToolInvoker:      c.toolsInvoker,
		ToolSpecs:        MathAgentToolsSpec,
	})
	if err != nil {
		return nil, fmt.Errorf("llm call failed: %w", err)
	}

	return &out, nil
}
