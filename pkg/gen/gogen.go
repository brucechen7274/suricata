package gen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"strings"

	"github.com/ostafen/suricata/pkg/spec"
)

func Generate(spec *spec.Spec) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by suricata-gen; DO NOT EDIT.\n\n")

	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName(spec.Package)))

	buf.WriteString(`import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/ostafen/suricata/runtime"
	"github.com/xeipuuv/gojsonschema"
)
` + "\n")

	if len(spec.Messages) > 0 {
		if err := generateMessageSchemas(&buf, spec.Messages); err != nil {
			return nil, err
		}
		generateTypes(&buf, spec.Messages)
	}

	// Generate RPC methods
	for name, svc := range spec.Agents {
		generateAgent(&buf, name, &svc, spec.Tools)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("warning: failed to format generated code: %v", err)
		return buf.Bytes(), nil
	}
	return src, nil
}

func generateMessageSchemas(buf *bytes.Buffer, messages map[string]spec.Message) error {
	gen := NewJSONSchemaGenerator()

	buf.WriteString("var (\n")
	for name, msg := range messages {
		schema, err := gen.GenerateJSONSchema(name, &msg, messages)
		if err != nil {
			return err
		}

		rawSchema, err := json.Marshal(schema)
		if err != nil {
			return err
		}

		buf.WriteString(fmt.Sprintf("\t%sSchema = gojsonschema.NewStringLoader(`%s`)\n", name, string(rawSchema)))
	}
	buf.WriteString(")\n")
	return nil
}

func generateTypes(buf *bytes.Buffer, messages map[string]spec.Message) {
	// Generate structs for messages
	buf.WriteString("type (\n")
	for name, msg := range messages {
		buf.WriteString(fmt.Sprintf("\t%s struct {\n", name))
		for _, field := range msg.Fields {
			goType := goTypeForField(field)
			fieldName := toCamelCase(field.Name)

			tagParts := []string{field.Name}
			if field.Optional || field.Repeated {
				tagParts = append(tagParts, "omitempty")
			}
			tag := fmt.Sprintf("`json:\"%s\"`", strings.Join(tagParts, ","))

			buf.WriteString(fmt.Sprintf("\t%s %s %s\n", fieldName, goType, tag))
		}
		buf.WriteString("}\n\n")
	}
	buf.WriteString(")\n")
}

func generateAgent(buf *bytes.Buffer, name string, agent *spec.Agent, tools map[string]spec.Tool) {
	generateToolsInterface(buf, name, agent.Tools, tools)
	generateToolsSpec(buf, name, agent.Tools, tools)

	instructions := escapeBackticks(agent.Instructions)
	fmt.Fprintf(buf, "var %sInstructions =  `%s`\n\n", name, instructions)

	// Generate client struct
	if len(agent.Tools) > 0 {
		fmt.Fprintf(buf, "type %sClient struct {\n\truntime *runtime.Runtime\n\ttools %sTools\n}\n\n", name, name)
		fmt.Fprintf(buf, "func New%sClient(invoker runtime.Invoker, tools %sTools) *%sClient {\n\treturn &%sClient{runtime: runtime.NewRuntime(runtime.NewChatSession(invoker)), tools: tools}\n}\n\n", name, name, name, name)
	} else {
		fmt.Fprintf(buf, "type %sClient struct {\n\truntime *runtime.Runtime\n}\n\n", name)
		fmt.Fprintf(buf, "func New%sClient(invoker runtime.Invoker) *%sClient {\n\treturn &%sClient{runtime: runtime.NewRuntime(invoker)}\n}\n\n", name, name, name)
	}

	generateUnmarshaller(buf, name, agent.Tools, tools)
	generateToolsInvoker(buf, name, agent.Tools, tools)

	// TODO: capitalize first letter of name
	for actionName, action := range agent.Actions {
		inType := action.Input
		outType := action.Output
		methodName := actionName

		buf.WriteString(fmt.Sprintf("func (c *%sClient) %s(ctx context.Context, in *%s) (*%s, error) {\n", name, methodName, inType, outType))

		buf.WriteString("\t// Validate input JSON\n")
		buf.WriteString("\tinBytes, err := json.Marshal(in)\n")
		buf.WriteString("\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"marshal input: %w\", err)\n\t}\n")

		// Validate input schema if available
		fmt.Fprintf(buf, "\tif %sSchema != nil {\n", inType)
		fmt.Fprintf(buf, "\t\tresult, err := gojsonschema.Validate(%sSchema, gojsonschema.NewBytesLoader(inBytes))\n", inType)
		buf.WriteString("\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"input schema validation error: %w\", err)\n\t\t}\n")
		buf.WriteString("\t\tif !result.Valid() {\n")
		buf.WriteString("\t\t\treturn nil, fmt.Errorf(\"input validation failed: %%v\", result.Errors())\n\t\t}\n")
		buf.WriteString("\t}\n\n")

		// Prepare prompt (raw string literal)
		prompt := escapeBackticks(action.Prompt)
		fmt.Fprintf(buf, "\tprompt := `%s`\n\n", prompt)

		buf.WriteString("\t// Invoke LLM runtime\n")
		fmt.Fprintf(buf, "\tout := %s{}\n", outType)
		buf.WriteString("\terr = c.runtime.Invoke(ctx, runtime.Request{\n")
		fmt.Fprintf(buf, "\t\tSkipInput: %t,\n", action.SkipInput)
		fmt.Fprintf(buf, "\t\tInstructions: %sInstructions,\n", name)
		buf.WriteString("\t\tPromptTemplate: prompt,\n")
		buf.WriteString("\t\tInput: in,\n")
		buf.WriteString("\t\tOutput: &out,\n")

		fmt.Fprintf(buf, "\t\tOutputSchema: %sSchema ,\n", outType)
		if len(agent.Tools) > 0 {
			fmt.Fprintf(buf, "\t\tToolUnmarshaller: %sToolsUnmarshaller,\n", name)
			buf.WriteString("\t\tToolInvoker: c.toolsInvoker,\n")
			fmt.Fprintf(buf, "\t\tToolSpecs: %sToolsSpec,\n", name)
		}

		buf.WriteString("\t})\n")
		buf.WriteString("\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"llm call failed: %w\", err)\n\t}\n\n")

		buf.WriteString("\treturn &out, nil\n")
		buf.WriteString("}\n\n")
	}
}

func generateToolsSpec(buf *bytes.Buffer, name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	fmt.Fprintf(buf, "var %sToolsSpec = []runtime.ToolSpec{", name)
	for _, name := range tools {
		t := toolsMap[name]
		fmt.Fprintf(buf, "{Name: \"%s\", Description: \"%s\", Schema: %sSchema},", name, t.Description, t.Input)
	}
	buf.WriteString("}\n\n")
}

func generateToolsInterface(buf *bytes.Buffer, name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	fmt.Fprintf(buf, "\ntype %sTools interface {\n", name)

	for _, toolName := range tools {
		tool := toolsMap[toolName]

		fmt.Fprintf(buf, "%s(in *%s) (*%s, error)\n", toolName, tool.Input, tool.Output)
	}

	buf.WriteString("}\n\n")
}

func generateUnmarshaller(buf *bytes.Buffer, name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	fmt.Fprintf(buf, "\nfunc %sToolsUnmarshaller(method string, data []byte) (any, error) {\n", name)
	buf.WriteString("\tswitch method {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		fmt.Fprintf(buf, "\t\t case \"%s\":\n\t\t\tvar payload %s\n\t\t\terr := json.Unmarshal(data, &payload)\n\t\t\treturn &payload, err\n", name, tool.Input)
	}

	buf.WriteString("\t}\n")
	buf.WriteString("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", method)`)
	buf.WriteString("\n}\n\n")
}

func generateToolsInvoker(buf *bytes.Buffer, name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	fmt.Fprintf(buf, "\nfunc (a *%sClient) toolsInvoker(ctx context.Context, name string, in any) (any, error) {\n", name)
	buf.WriteString("\tswitch name {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		fmt.Fprintf(buf, "\t\t case \"%s\":\n\t\t\treturn a.tools.%s(in.(*%s))\n", name, name, tool.Input)
	}

	buf.WriteString("\t}\n")
	buf.WriteString("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", name)`)
	buf.WriteString("\n}\n\n")
}

func packageName(full string) string {
	parts := strings.Split(full, ".")
	return parts[len(parts)-1]
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

// goTypeForField maps your DSL field to Go type considering optional/repeated
func goTypeForField(f spec.Field) string {
	var goType string
	switch f.Type {
	case "string":
		goType = "string"
	case "int", "int32", "int64":
		goType = "int"
	case "float", "float32", "float64":
		goType = "float64"
	case "bool":
		goType = "bool"
	default:
		// Custom message type
		goType = f.Type
	}

	// Pointer for optional scalar or custom type (but not slices)
	if f.Optional && !f.Repeated {
		goType = "*" + goType
	}

	if f.Repeated {
		goType = "[]" + goType
	}

	return goType
}

func escapeBackticks(s string) string {
	return strings.ReplaceAll(s, "`", "` + \"`\" + `")
}
