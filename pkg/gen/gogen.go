package gen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"strings"

	"github.com/ostafen/suricata/pkg/spec"
)

type CodeGenerator struct {
	buf bytes.Buffer
}

func (gen *CodeGenerator) write(format string, a ...any) {
	if len(a) == 0 {
		gen.buf.WriteString(format)
	} else {
		fmt.Fprintf(&gen.buf, format, a...)
	}
}

func (gen *CodeGenerator) Generate(spec *spec.Spec) ([]byte, error) {
	gen.buf.Reset()

	gen.write("// Code generated by suricata-gen; DO NOT EDIT.\n\n")
	gen.write("package %s\n\n", packageName(spec.Package))

	gen.write(`import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/ostafen/suricata/runtime"
	"github.com/xeipuuv/gojsonschema"
)
` + "\n")

	if len(spec.Messages) > 0 {
		if err := gen.generateMessageSchemas(spec.Messages); err != nil {
			return nil, err
		}
		gen.generateTypes(spec.Messages)
	}

	// Generate RPC methods
	for name, svc := range spec.Agents {
		gen.generateAgent(name, &svc, spec.Tools)
	}

	src, err := format.Source(gen.buf.Bytes())
	if err != nil {
		log.Printf("warning: failed to format generated code: %v", err)
		return gen.buf.Bytes(), nil
	}
	return src, nil
}

func (gen *CodeGenerator) generateMessageSchemas(messages map[string]spec.Message) error {
	schemaGen := NewJSONSchemaGenerator()

	gen.write("var (\n")
	for name, msg := range messages {
		schema, err := schemaGen.GenerateJSONSchema(name, &msg, messages)
		if err != nil {
			return err
		}

		rawSchema, err := json.Marshal(schema)
		if err != nil {
			return err
		}

		gen.write("\t%sSchema = gojsonschema.NewStringLoader(`%s`)\n", name, string(rawSchema))
	}
	gen.write(")\n")
	return nil
}

func (gen *CodeGenerator) generateTypes(messages map[string]spec.Message) {
	// Generate structs for messages
	gen.write("type (\n")
	for name, msg := range messages {
		gen.write(fmt.Sprintf("\t%s struct {\n", name))
		for _, field := range msg.Fields {
			goType := goTypeForField(field)
			fieldName := toCamelCase(field.Name)

			tagParts := []string{field.Name}
			if field.Optional || field.Repeated {
				tagParts = append(tagParts, "omitempty")
			}
			tag := fmt.Sprintf("`json:\"%s\"`", strings.Join(tagParts, ","))

			gen.write(fmt.Sprintf("\t%s %s %s\n", fieldName, goType, tag))
		}
		gen.write("}\n\n")
	}
	gen.write(")\n")
}

func (gen *CodeGenerator) generateAgent(name string, agent *spec.Agent, tools map[string]spec.Tool) {
	gen.generateToolsInterface(name, agent.Tools, tools)
	gen.generateToolsSpec(name, agent.Tools, tools)

	instructions := escapeBackticks(agent.Instructions)
	gen.write("var %sInstructions =  `%s`\n\n", name, instructions)

	// Generate client struct
	if len(agent.Tools) > 0 {
		gen.write("type %sClient struct {\n\truntime *runtime.Runtime\n\ttools %sTools\n}\n\n", name, name)
		gen.write("func New%sClient(invoker runtime.Invoker, tools %sTools) *%sClient {\n\treturn &%sClient{runtime: runtime.NewRuntime(runtime.NewChatSession(invoker)), tools: tools}\n}\n\n", name, name, name, name)
	} else {
		gen.write("type %sClient struct {\n\truntime *runtime.Runtime\n}\n\n", name)
		gen.write("func New%sClient(invoker runtime.Invoker) *%sClient {\n\treturn &%sClient{runtime: runtime.NewRuntime(invoker)}\n}\n\n", name, name, name)
	}

	gen.generateUnmarshaller(name, agent.Tools, tools)
	gen.generateToolsInvoker(name, agent.Tools, tools)

	// TODO: capitalize first letter of name
	for actionName, action := range agent.Actions {
		inType := action.Input
		outType := action.Output
		methodName := actionName

		gen.write(fmt.Sprintf("func (c *%sClient) %s(ctx context.Context, in *%s) (*%s, error) {\n", name, methodName, inType, outType))

		gen.write("\t// Validate input JSON\n")
		gen.write("\tinBytes, err := json.Marshal(in)\n")
		gen.write("\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"marshal input: %w\", err)\n\t}\n")

		// Validate input schema if available
		gen.write("\tif %sSchema != nil {\n", inType)
		gen.write("\t\tresult, err := gojsonschema.Validate(%sSchema, gojsonschema.NewBytesLoader(inBytes))\n", inType)
		gen.write("\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"input schema validation error: %w\", err)\n\t\t}\n")
		gen.write("\t\tif !result.Valid() {\n")
		gen.write("\t\t\treturn nil, fmt.Errorf(\"input validation failed: %%v\", result.Errors())\n\t\t}\n")
		gen.write("\t}\n\n")

		// Prepare prompt (raw string literal)
		prompt := escapeBackticks(action.Prompt)
		gen.write("\tprompt := `%s`\n\n", prompt)

		gen.write("\t// Invoke LLM runtime\n")
		gen.write("\tout := %s{}\n", outType)
		gen.write("\terr = c.runtime.Invoke(ctx, runtime.Request{\n")
		gen.write("\t\tSkipInput: %t,\n", action.SkipInput)
		gen.write("\t\tInstructions: %sInstructions,\n", name)
		gen.write("\t\tPromptTemplate: prompt,\n")
		gen.write("\t\tInput: in,\n")
		gen.write("\t\tOutput: &out,\n")

		gen.write("\t\tOutputSchema: %sSchema ,\n", outType)
		if len(agent.Tools) > 0 {
			gen.write("\t\tToolUnmarshaller: %sToolsUnmarshaller,\n", name)
			gen.write("\t\tToolInvoker: c.toolsInvoker,\n")
			gen.write("\t\tToolSpecs: %sToolsSpec,\n", name)
		}

		gen.write("\t})\n")
		gen.write("\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"llm call failed: %w\", err)\n\t}\n\n")

		gen.write("\treturn &out, nil\n")
		gen.write("}\n\n")
	}
}

func (gen *CodeGenerator) generateToolsSpec(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("var %sToolsSpec = []runtime.ToolSpec{", name)
	for _, name := range tools {
		t := toolsMap[name]
		gen.write("{Name: \"%s\", Description: \"%s\", Schema: %sSchema},", name, t.Description, t.Input)
	}
	gen.write("}\n\n")
}

func (gen *CodeGenerator) generateToolsInterface(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\ntype %sTools interface {\n", name)

	for _, toolName := range tools {
		tool := toolsMap[toolName]

		gen.write("%s(in *%s) (*%s, error)\n", toolName, tool.Input, tool.Output)
	}

	gen.write("}\n\n")
}

func (gen *CodeGenerator) generateUnmarshaller(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\nfunc %sToolsUnmarshaller(method string, data []byte) (any, error) {\n", name)
	gen.write("\tswitch method {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		gen.write("\t\t case \"%s\":\n\t\t\tvar payload %s\n\t\t\terr := runtime.UnmarshalValidate(data, &payload, %sSchema)\n\t\t\treturn &payload, err\n", name, tool.Input, tool.Input)
	}

	gen.write("\t}\n")
	gen.write("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", method)`)
	gen.write("\n}\n\n")
}

func (gen *CodeGenerator) generateToolsInvoker(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\nfunc (a *%sClient) toolsInvoker(ctx context.Context, name string, in any) (any, error) {\n", name)
	gen.write("\tswitch name {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		gen.write("\t\t case \"%s\":\n\t\t\treturn a.tools.%s(in.(*%s))\n", name, name, tool.Input)
	}

	gen.write("\t}\n")
	gen.write("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", name)`)
	gen.write("\n}\n\n")
}

func packageName(full string) string {
	parts := strings.Split(full, ".")
	return parts[len(parts)-1]
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

// goTypeForField maps your DSL field to Go type considering optional/repeated
func goTypeForField(f spec.Field) string {
	var goType string
	switch f.Type {
	case "string":
		goType = "string"
	case "int", "int32", "int64":
		goType = "int"
	case "float", "float32", "float64":
		goType = "float64"
	case "bool":
		goType = "bool"
	default:
		// Custom message type
		goType = f.Type
	}

	// Pointer for optional scalar or custom type (but not slices)
	if f.Optional && !f.Repeated {
		goType = "*" + goType
	}

	if f.Repeated {
		goType = "[]" + goType
	}

	return goType
}

func escapeBackticks(s string) string {
	return strings.ReplaceAll(s, "`", "` + \"`\" + `")
}
