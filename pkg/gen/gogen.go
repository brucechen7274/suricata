// Copyright (c) 2025 Suricata Contributors
// Original Author: Stefano Scafiti
//
// This file is part of Suricata: Type-Safe AI Agents for Go.
//
// Licensed under the MIT License. You may obtain a copy of the License at
//
//	https://opensource.org/licenses/MIT
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"strings"

	"github.com/ostafen/suricata/pkg/spec"
)

type CodeGenerator struct {
	buf bytes.Buffer
}

func (gen *CodeGenerator) write(format string, a ...any) {
	if len(a) == 0 {
		gen.buf.WriteString(format)
	} else {
		fmt.Fprintf(&gen.buf, format, a...)
	}
}

func (gen *CodeGenerator) Generate(spec *spec.Spec) ([]byte, error) {
	gen.buf.Reset()

	gen.write("// Code generated by suricata-gen; DO NOT EDIT.\n\n")
	gen.write("package %s\n\n", packageName(spec.Package))

	gen.write(`import (
	"context"
	"fmt"
	"github.com/ostafen/suricata/runtime"
	"github.com/xeipuuv/gojsonschema"
)
` + "\n")

	if len(spec.Messages) > 0 {
		if err := gen.generateMessageSchemas(spec.Messages); err != nil {
			return nil, err
		}
		gen.generateTypes(spec.Messages)
	}

	// Generate RPC methods
	for name, svc := range spec.Agents {
		gen.generateAgent(name, &svc, spec.Tools)
	}

	src, err := format.Source(gen.buf.Bytes())
	if err != nil {
		return gen.buf.Bytes(), err
	}
	return src, nil
}

func (gen *CodeGenerator) generateMessageSchemas(messages map[string]spec.Message) error {
	schemaGen := NewJSONSchemaGenerator()

	gen.write("var (\n")
	for name, msg := range messages {
		schema, err := schemaGen.GenerateJSONSchema(name, &msg, messages)
		if err != nil {
			return err
		}

		rawSchema, err := json.Marshal(schema)
		if err != nil {
			return err
		}

		gen.write("\t%sSchema = gojsonschema.NewStringLoader(`%s`)\n", name, string(rawSchema))
	}
	gen.write(")\n")
	return nil
}

func (gen *CodeGenerator) generateTypes(messages map[string]spec.Message) {
	// Generate structs for messages
	gen.write("type (\n")
	for name, msg := range messages {
		gen.write(fmt.Sprintf("\t%s struct {\n", name))
		for _, field := range msg.Fields {
			goType := goTypeForField(field)
			fieldName := toCamelCase(field.Name)

			tagParts := []string{field.Name}
			if field.Optional || field.Repeated {
				tagParts = append(tagParts, "omitempty")
			}
			tag := fmt.Sprintf("`json:\"%s\"`", strings.Join(tagParts, ","))

			gen.write(fmt.Sprintf("\t%s %s %s\n", fieldName, goType, tag))
		}
		gen.write("}\n\n")
	}
	gen.write(")\n")
}

func getAgentTypeName(name string) string {
	name = CapitalizeFirst(name)

	if strings.HasSuffix(strings.ToLower(name), "agent") {
		return name[:len(name)-len("agent")] + "Agent"
	}
	return name + "Agent"
}

func (gen *CodeGenerator) generateAgent(name string, agent *spec.Agent, tools map[string]spec.Tool) {
	name = getAgentTypeName(name)

	gen.generateToolsInterface(name, agent.Tools, tools)
	gen.generateToolsSpec(name, agent.Tools, tools)

	instructions := escapeBackticks(agent.Instructions)
	gen.write("var %sInstructions =  `%s`\n\n", name, instructions)

	if len(agent.Tools) > 0 {
		gen.write("type %s struct {\n\truntime *runtime.Runtime\n\ttools %sTools\n}\n\n", name, name)
		gen.write("func New%s(invoker runtime.Invoker, tools %sTools) *%s {\n\treturn &%s{runtime: runtime.NewRuntime(invoker), tools: tools}\n}\n\n", name, name, name, name)
	} else {
		gen.write("type %s struct {\n\truntime *runtime.Runtime\n}\n\n", name)
		gen.write("func New%s(invoker runtime.Invoker) *%s {\n\treturn &%s{runtime: runtime.NewRuntime(invoker)}\n}\n\n", name, name, name)
	}

	gen.generateUnmarshaller(name, agent.Tools, tools)
	gen.generateToolsInvoker(name, agent.Tools, tools)

	for actionName, action := range agent.Actions {
		inType := CapitalizeFirst(action.Input)
		outType := CapitalizeFirst(action.Output)
		methodName := CapitalizeFirst(actionName)

		gen.write(fmt.Sprintf("func (c *%s) %s(ctx context.Context, in *%s) (*%s, error) {\n", name, methodName, inType, outType))

		// Prepare prompt (raw string literal)
		prompt := escapeBackticks(action.Prompt)
		gen.write("\tprompt := `%s`\n\n", prompt)

		gen.write("\t// Invoke LLM runtime\n")
		gen.write("\tout := %s{}\n", outType)
		gen.write("\terr := c.runtime.Invoke(ctx, runtime.Request{\n")
		gen.write("\t\tSkipInput: %t,\n", action.SkipInput)
		gen.write("\t\tInstructions: %sInstructions,\n", name)
		gen.write("\t\tPromptTemplate: prompt,\n")
		gen.write("\t\tInput: in,\n")
		gen.write("\t\tOutput: &out,\n")
		gen.write("\t\tInputSchema: %sSchema ,\n", inType)
		gen.write("\t\tOutputSchema: %sSchema ,\n", outType)

		if len(agent.Tools) > 0 {
			gen.write("\t\tToolUnmarshaller: c.unmarshaller,\n")
			gen.write("\t\tToolInvoker: c.toolsInvoker,\n")
			gen.write("\t\tToolSpecs: %sToolsSpec,\n", name)
		}

		gen.write("\t})\n")
		gen.write("\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"llm call failed: %w\", err)\n\t}\n\n")

		gen.write("\treturn &out, nil\n")
		gen.write("}\n\n")
	}
}

func (gen *CodeGenerator) generateToolsSpec(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("var %sToolsSpec = []runtime.ToolSpec{", name)
	for _, name := range tools {
		t := toolsMap[name]
		gen.write("{Name: \"%s\", Description: \"%s\", Schema: %sSchema},", CapitalizeFirst(name), t.Description, t.Input)
	}
	gen.write("}\n\n")
}

func (gen *CodeGenerator) generateToolsInterface(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\ntype %sTools interface {\n", name)

	for _, toolName := range tools {
		tool := toolsMap[toolName]

		gen.write("%s(ctx context.Context, in *%s) (*%s, error)\n", CapitalizeFirst(toolName), tool.Input, tool.Output)
	}

	gen.write("}\n\n")
}

func (gen *CodeGenerator) generateUnmarshaller(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\nfunc (a *%s) unmarshaller(method string, data []byte) (any, error) {\n", name)
	gen.write("\tswitch method {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		gen.write("\t\t case \"%s\":\n\t\t\tvar payload %s\n\t\t\terr := runtime.UnmarshalValidate(data, &payload, %sSchema)\n\t\t\treturn &payload, err\n", name, tool.Input, tool.Input)
	}

	gen.write("\t}\n")
	gen.write("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", method)`)
	gen.write("\n}\n\n")
}

func (gen *CodeGenerator) generateToolsInvoker(name string, tools []string, toolsMap map[string]spec.Tool) {
	if len(tools) == 0 {
		return
	}

	gen.write("\nfunc (a *%s) toolsInvoker(ctx context.Context, name string, in any) (any, error) {\n", name)
	gen.write("\tswitch name {\n")

	for _, name := range tools {
		tool := toolsMap[name]
		gen.write("\t\t case \"%s\":\n\t\t\treturn a.tools.%s(ctx, in.(*%s))\n", name, name, tool.Input)
	}

	gen.write("\t}\n")
	gen.write("\n\t" + `return nil, fmt.Errorf("no such tool: \"%s\"", name)`)
	gen.write("\n}\n\n")
}

func packageName(full string) string {
	parts := strings.Split(full, ".")
	return parts[len(parts)-1]
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		parts[i] = CapitalizeFirst(p)
	}
	return strings.Join(parts, "")
}

func goTypeForField(f spec.Field) string {
	var goType string
	switch f.Type {
	case "string":
		goType = "string"
	case "int", "int32", "int64":
		goType = "int"
	case "float", "float32", "float64":
		goType = "float64"
	case "bool":
		goType = "bool"
	default:
		// Custom message type
		goType = f.Type
	}

	// Pointer for optional scalar or custom type (but not slices)
	if f.Optional && !f.Repeated {
		goType = "*" + goType
	}

	if f.Repeated {
		goType = "[]" + goType
	}
	return goType
}

func escapeBackticks(s string) string {
	return strings.ReplaceAll(s, "`", "` + \"`\" + `")
}

func CapitalizeFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
